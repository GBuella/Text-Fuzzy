#line
#include <string.h>
#include <stdio.h>
/* For INT_MAX/INT_MIN */
#include <limits.h>
#include "text-fuzzy.h"
#include "edit-distance-[% stem %].h"
[%- IF trans %]
#line

/* For malloc. */

#include <stdlib.h>

/* Our unsorted dictionary linked list.       */

struct dictionary {
    [% type %] key;    /* the character        */
    unsigned int value;  /* character occurance  */
    struct dictionary* next;
};

typedef struct dictionary item;

static __inline item * push (unsigned int key, item * curr)
{
    item * head;
    head = malloc (sizeof (item));   
    head->key = key;
    head->value = 0;
    head->next = curr;
    return head;
}

static __inline item * find (item * head, unsigned int key)
{
    item * iterator = head;
    while (iterator) {
	if (iterator->key == key){
	    return iterator;
	}
	iterator = iterator->next;
    }
    return NULL;
}

/* find & push in 1 function (sperg optimization) */

static __inline item * uniquePush (item * head, unsigned int key)
{
    item * iterator = head;

    while(iterator){
	if(iterator->key == key){
	    return head;
	}
	iterator = iterator->next;
    }
    return push(key,head); 
}

/* Free the memory associated with "head". */

static void dict_free (item * head)
{
    item * iterator = head;
    while(iterator){
	item * temp = iterator;
	iterator = iterator->next;
	free(temp);
    }
    
    head = NULL;
}

static int min (int a, int b)
{
    if (a > b) {
	return b;
    }
    return a;
}


[%- END %]
#line 1 "declaration"
[% INCLUDE declaration %]
{
[%- IF trans %]
#line
[% IF ed_type == 'int' %]
#line
    const [% type %] * word2 = (const [% type %] *) tf->text.unicode;
    int len2 = tf->text.ulength;
[% ELSIF ed_type == 'char' %]
#line
    const [% type %] * word2 = (const [% type %] *) tf->text.text;
    int len2 = tf->text.length;
[% ELSE %]
#line
    fprintf (stderr, "Unhandled type [% type %].\n");
    exit (1);
[% END %]
#line

    /* keep track of dictionary linked list position */

    item *head = NULL;

    unsigned int swapScore,targetCharCount,i;
    unsigned int matrix[len1 + 2][len2 + 2];
    unsigned int score_ceil = len1 + len2;

    if (len1 == 0) {
	return len2;
    }
    if (len2 == 0) {
	return len1;
    }
 
    /* intialize matrix start values */

    matrix[0][0] = score_ceil;  
    matrix[1][0] = score_ceil;
    matrix[0][1] = score_ceil;
    matrix[1][1] = 0;

    head = uniquePush (uniquePush (head, word1[0]), word2[0]);

    for (i = 1; i <= len1; i++) { 
	int swapCount;
	int j;

	head = uniquePush (head, word1[i]);
	matrix[i+1][1] = i;
	matrix[i+1][0] = score_ceil;
	
	swapCount = 0;

	for (j = 1; j <= len2; j++){
	    if (i == 1) {
		/* only initialize on the first pass     */
		/* optimized over 2 additional for loops */
		head = uniquePush (head, word2[j]);
		matrix[1][j + 1] = j;
		matrix[0][j + 1] = score_ceil;
	    }

	    targetCharCount = find (head, word2[j-1])->value;
	    swapScore = matrix[targetCharCount][swapCount] + i - targetCharCount - 1 + j - swapCount;
	    
	    if(word1[i-1] != word2[j-1]){      
		matrix[i+1][j + 1] = min(swapScore,(min(matrix[i][j], min(matrix[i+1][j], matrix[i][j + 1])) + 1));
	    }
	    else{ 
		swapCount = j;
		matrix[i+1][j + 1] = min (matrix[i][j], swapScore);
	    } 
	}
	
	/* We will return a huge value here if the */
	/* current score > maxDistance   */
	if(tf->max_distance != 0 && tf->max_distance < matrix[i+1][len2+1]) {
	    dict_free(head);
	    return INT_MAX / 0x1000;
	}
	
	
	find (head, word1[i-1])->value = i;
    }

    dict_free (head);

    return matrix[len1 + 1][len2 + 1];

[%- ELSE # trans %]
#line
[%- IF use_text_fuzzy %]
#line
    /* Pull the values from "tf". */
[% IF ed_type == 'int' %]
#line
    const [% type %] * word2 = (const [% type %] *) tf->text.unicode;
    int len2 = tf->text.ulength;
[% ELSIF ed_type == 'char' %]
#line
    const [% type %] * word2 = (const [% type %] *) tf->text.text;
    int len2 = tf->text.length;
[% ELSE %]
#line
    fprintf (stderr, "Unhandled type [% type %].\n");
    exit (1);
[% END %]
[%- END # use_text_fuzzy %]
#line

    /* Matrix is the dynamic programming matrix. We economize on space
       by having only two columns. */

    int matrix[2][len2 + 1];
    int i;
    int j;
    int large_value;
[%- IF use_text_fuzzy %]
#line
    int max;

    max = tf->max_distance;
[%- END # use_text_fuzzy %]
#line

    /*
      Initialize the 0 row of "matrix".

        0  
        1  
        2  
        3  

     */

    if (max >= 0) {
        large_value = max + 1;
    }
    else {
        if (len2 > len1) {
            large_value = len2;
        }
        else {
            large_value = len1;
        }
    }

    for (j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }

    /* Loop over column. */
    for (i = 1; i <= len1; i++) {
        [% type %] c1;
        /* The first value to consider of the ith column. */
        int min_j;
        /* The last value to consider of the ith column. */
        int max_j;
        /* The smallest value of the matrix in the ith column. */
        int col_min;
        /* The next column of the matrix to fill in. */
        int next;
        /* The previously-filled-in column of the matrix. */
        int prev;

        c1 = word1[i-1];
        min_j = 1;
        max_j = len2;
        if (max >= 0) {
            if (i > max) {
                min_j = i - max;
            }
            if (len2 > max + i) {
                max_j = max + i;
            }
        }
        col_min = INT_MAX;
        next = i % 2;
        if (next == 1) {
            prev = 0;
        }
        else {
            prev = 1;
        }
        matrix[next][0] = i;
        /* Loop over rows. */
        for (j = 1; j <= len2; j++) {
            if (j < min_j || j > max_j) {
                /* Put a large value in there. */
                matrix[next][j] = large_value;
            }
            else {
                [% type %] c2;

                c2 = word2[j-1];
                if ([% compare_c1_c2 %]) {
                    /* The character at position i in word1 is the same as
                       the character at position j in word2. */
                    matrix[next][j] = matrix[prev][j-1];

                }
                else {
                    /* The character at position i in word1 is not the
                       same as the character at position j in word2, so
                       work out what the minimum cost for getting to cell
                       i, j is. */
                    int delete;
                    int insert;
                    int substitute;
                    int minimum;

                    delete = matrix[prev][j] + [% delete_cost %];
                    insert = matrix[next][j-1] + [% insert_cost %];
                    substitute = matrix[prev][j-1] + [% substitute_cost %];
                    minimum = delete;
                    if (insert < minimum) {
                        minimum = insert;
                    }
                    if (substitute < minimum) {
                        minimum = substitute;
                    }
                    matrix[next][j] = minimum;
                }
            }
            /* Find the minimum value in the ith column. */
            if (matrix[next][j] < col_min) {
                col_min = matrix[next][j];
            }
        }
        if (max >= 0) {
            if (col_min > max) {
                /* All the elements of the ith column are greater than the
                   maximum, so no match less than or equal to max can be
                   found by looking at succeeding columns. */
                return large_value;
            }
        }
    }
    return matrix[len1 % 2][len2];
[%- END # trans %]
#line
}

